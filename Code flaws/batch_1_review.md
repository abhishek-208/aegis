Code Review: Batch 1 (Config & Aggregator)1. The "Median Hugger" Vulnerability (Critical)In aegis (Aegis), your credit score calculation is:raw_anomaly_credit = 1.0 / (approved_scores + RWA_EPSILON)The Problem:This inverse function ($1/x$) is extremely aggressive.If a client is very close to the median (e.g., $S_k \approx 0$), their score shoots toward infinity (limited only by 1e-9).Consequence: A single client (or attacker) that mimics the median slightly better than others will dominate the aggregation. If an attacker simply returns the global model from the previous round (distance $\approx 0$), they might get 99% of the weight, effectively freezing your model training.Recommendation: Keep it for now to match your spec, but if training stalls, we must switch to a Softmax decay or a bounded linear decay.2. GPU Memory BottleneckIn _flatten_weights:return torch.cat([p.flatten() for p in weights_dict.values()]).to(DEVICE)
You are moving every client's full parameter vector to the GPU immediately.The Risk: If you use a VGG/ResNet model (~11M parameters) with 30 clients:$11,000,000 \times 4 \text{ bytes} \times 30 \text{ clients} \approx 1.3 \text{ GB}$.This is manageable for CIFAR-10/ResNet18. However, if you scale to 100 clients or larger models, this will trigger a CUDA Out Of Memory (OOM) error.Fix: Keep vectors on CPU, compute distances on CPU, and only move the aggregated result to GPU. (Ignore this if you have high-end VRAM).3. Config & HyperparametersFRACTION_BYZANTINE = 0.4: This is very high. Theoretical limit for standard BFT is $<33\%$. Krum claims tolerance up to $<50\%$, but in practice, 40% attackers often successfully bias the median. Be prepared for the model to degrade significantly at this level.RWA_MAD_THRESHOLD = 3.0: Standard and acceptable.4. Multi-Krum LogicYour implementation:r = max(1, n - f - 2)
This is a safe implementation. Many implementations fail here by allowing $r$ to be negative or zero. Your guards are good.5. Aggregation LogicThe math in aegis regarding n_k is correct.Formula: $(\frac{n_k}{n}) \times (\frac{1}{S_k + \epsilon})$Code: raw_credits = raw_anomaly_credit * approved_data_sizes followed by normalization.Since $n$ (total data) is constant for all clients, dividing by it cancels out during normalization. The code is mathematically equivalent to the formula.